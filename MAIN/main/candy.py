# file created: 2024-06-04 06:21:36.840453

# this files has been generated by CandyTranslate.com  Please do not change manually
# author: Next Level Sense

# Available functions:
#    render - replacement for django render function
#    path - replacement for django path function. please use with * when replacing in urls.py
#    supported_languages - list that contains all available languages for this site
# Functions to be used in django templates:
#    languageReferences - create 'alternate' language references for SEO.
#        put it inside of the <head> section of the page in format {{languageReferences|safe}}
#    lang - current language. Used mostly in <html lang="{{lang}}">
#    languageMenu - adding language selection for your page. Format: {{languageMenu|safe}}
#    <<link variables>> - create linking to correct language link. 
#    usage:
#    for translated pages change {% url "my_page" %}
#    to name without quotes:     {% url my_page %}


supported_languages = ['en', 'ms']

def translation_dictionary(lang):
    if lang == 'en': return {
        'Anemochory_Title':'''Anemochory''',
        'Anemochory_Verse':'''Quranic Verse''',
        'Anemochory_Translation':'''“We send fertilizing winds, and bring down rain from the sky for you to drink. It is not you who hold its reserves.”''',
        'Anemochory_Insight':'''Scientific Insights''',
        'Anemochory_Science':'''Pollination is one of the processes of transferring pollen from anther to stigma. It can occur with the assistance of pollinating agents such as wind, animals, and water. Pollination by wind is called "Abiotic". This theory was first mentioned by Christian Konrad Sprengel in his book Das entdeckte Geheimnis der Natur im Bau und in der Befruchtung der Blumen (Berlin 1793) (1161 years after the death of the Prophet Muhammad (632 CE)).''',
        'Anemochory_Sciencept2':'''In Surah Al-Hijr: verse 22, the word used is "lawaaqih," the plural form of "laqih" from the word "laqaha," which means to marry or to impregnate. In this context, marrying/impregnating means the wind carries flower seeds from the anther to the stigma to be married or impregnated. It can be the transfer of seeds on the same plant or different plants.''',
        'Celestial_h1':'''Celestial Bodies and Their Orbits''',
        'Celestial_h4':'''Quranic Verse''',
        'Celestial_p1':'''“And by the sky full of pathways” - Adh-Dhariyat (51:7)''',
        'Celestial_p2':'''Scientific Insights''',
        'Celestial_p3':'''The scientific theory regarding celestial bodies moving in orbits began with Johannes Kepler in 1621, 989 years after the death of Prophet Muhammad (PBUH). This was detailed in his work "Mysterium Cosmographicum" (The Sacred Mystery of the Cosmos), Second Edition (1621).''',
        'Celestial_p4':'''References:''',
        'all_home':'''Home''',
        'all_story':'''Stories In Quran''',
        'all_science':'''Sciences In Quran''',
        'all_dua':'''Dua''',
        'all_quiz':'''Quiz''',
        }
    if lang == 'ms': return {
        'Anemochory_Title':'''Penyebaran Biji Benih Melalui Angin''',
        'Anemochory_Verse':'''Ayat Al-Quran''',
        'Anemochory_Translation':'''“Kami mengirimkan angin yang membaja, dan Kami menurunkan hujan dari langit untuk kamu minum. Bukan kamu yang memegang rizabnya.”''',
        'Anemochory_Insight':'''Wawasan Saintifik''',
        'Anemochory_Science':'''Pendebungaan adalah salah satu proses pemindahan debunga dari anter ke stigma. Ia boleh berlaku dengan bantuan agen pendebungaan seperti angin, haiwan, dan air. Pendebungaan oleh angin dipanggil "Abiotik". Teori ini pertama kali disebut oleh Christian Konrad Sprengel dalam bukunya Das entdeckte Geheimnis der Natur im Bau und in der Befruchtung der Blumen (Berlin 1793) (1161 tahun selepas kewafatan Nabi Muhammad (632 CE)).''',
        'Anemochory_Sciencept2':'''Dalam Surah Al-Hijr: ayat 22, perkataan yang digunakan ialah "lawaaqih," bentuk jamak "laqih" daripada perkataan "laqaha," yang bermaksud berkahwin atau menghamili. Dalam konteks ini, mengahwini/menghamil bermaksud angin membawa benih bunga dari kepala sari ke stigma untuk dikahwinkan atau dihamilkan. Ia boleh menjadi pemindahan benih pada tumbuhan yang sama atau tumbuhan yang berbeza.''',
        'Celestial_h1':'''Planet-Planet Dan Isi Langit Bergerak Ikut Orbit''',
        'Celestial_h4':'''Ayat Al-Quran''',
        'Celestial_p1':'''"Demi langit yang mempunyai jalan-jalan (yang palbagai bentuk keadaannya"  - Adh-Dhariyat (51:7)''',
        'Celestial_p2':'''Wawasan Saintifik''',
        'Celestial_p3':'''Teori sains berkaitan perkara ini bermula pada 1621 oleh Johannes Kepler. (989 tahun selepas Rasulullah saw wafat (632M)). Teori sains berkaitan perkara ini bermula pada 1621 oleh Johannes Kepler. (989 tahun selepas Rasulullah saw wafat (632M)).

Dari hasil karangannya Mysterium Cosmographicum (The Sacred Mystery of the Cosmos) Edisi Kedua (1621)''',
        'Celestial_p4':'''Rujukan:''',
        'all_home':'''Laman Utama''',
        'all_story':'''Kisah Dalam Al-Quran''',
        'all_science':'''Sains Dalam Al-Quran''',
        'all_dua':'''Doa''',
        'all_quiz':'''Kuiz''',
        }


def detectLanguage(request):
    languageDetected = supported_languages[0]
    pagePath = request.path
    if pagePath[-1] == '/': pagePath=pagePath[:-1]
    pagePath = pagePath.split('?')[0]
    pagePath = pagePath.split('#')[0]
    lastPath = pagePath.split('/')[-1]
    if lastPath in supported_languages[1:]:
        languageDetected = lastPath
    return languageDetected


def translated(requestOrLang,TranslateVariable):
    if requestOrLang in supported_languages:
        lang=requestOrLang
    else:
        lang = detectLanguage(requestOrLang)
    return translation_dictionary(lang)[TranslateVariable]


def localizeLink(request, link):
    lang=detectLanguage(request)
    if lang == supported_languages[0]: return link
    index1 = link.find('#')
    index2 = link.find('?')
    if index1 == -1 and index2 == -1: smallest_index = len(link)
    elif index1 == -1: smallest_index = index2
    elif index2 == -1: smallest_index = index1
    else: smallest_index = min(index1, index2)
    path = link[:smallest_index]
    if path[-1] == '/': path=path[:-1]
    return path+'/'+lang+link[smallest_index:]


from django.shortcuts import redirect as org_redirect
def redirect(request, to, *args, permanent=False, **kwargs):
    lang=detectLanguage(request)
    if lang in supported_languages[1:]:
        to=to+'_'+lang
    return org_redirect(to, *args, permanent=permanent, **kwargs)


from django.urls import path as org_path
def path(route, view, kwargs=None, name=None):
    if route == '':
        return [org_path('', view, kwargs, name),org_path('ms', view, kwargs, name+'_ms'),]
    if route[-1] == '/': route=route[:-1]
    return [org_path(route, view, kwargs, name),org_path(route+'/ms', view, kwargs, name+'_ms'),]


def langRef(path_ref):
    last=path_ref.split('/')[-1]
    if last in supported_languages:
        path_ref=path_ref[:-len(last)-1]
    result='<link rel="alternate" hreflang="en" href="'+addLinks(path_ref,'')+'" />\n'
    result+='<link rel="alternate" hreflang="ms" href="'+addLinks(path_ref,'ms')+'" />\n'
    result+='<link rel="alternate" hreflang="x-default" href="'+addLinks(path_ref,'')+'" />\n'
    return result


from django.urls import get_resolver
def translatedLinks(lang):
    names=[]
    for i in get_resolver().url_patterns:
        if hasattr(i, 'name'):
            if i.name:
                names.append(i.name)
    result = {}
    if lang == supported_languages[0]:
        for i in names:
            if i[-3:] not in ['_ms'] and names.count(i+'_ms'):
                result.update({i:i})
        return result
    for i in names:
        if names.count(i+'_'+lang):
            result.update({i:i+'_'+lang})
    return result


def languageMenu(request, lang):
    path = request.path
    remainder = request.get_full_path()[len(path):]
    selected = [' ', ' ']
    selected[supported_languages.index(lang)]=' selected '
    if supported_languages.index(lang):
        path=path[:-3]
    result = '<select id="languageMenu" onchange="window.location = this.value;">'
    if path == '/': path = ''
    if path =='':
        result += '<option'+selected[0]+'value="/'+remainder+'">English (English)</option>'
    else:
        result += '<option'+selected[0]+'value="' + path + remainder +'">English (English)</option>'
    result += '<option'+selected[1]+'value="' + path +'/ms'+remainder+'">Malay (Bahasa Melayu)</option>'
    result += '</select>'
    return result


from django.shortcuts import render as org_render
def render(request, template_name, context=None, *args, **kwargs):
    lang=detectLanguage(request)
    if context == None:
        context={}
    return org_render(request, template_name, {**context,
                                                **translation_dictionary(lang),
                                                'lang':lang,
                                                'languageReferences':langRef(request.build_absolute_uri()),
                                                'languageMenu':languageMenu(request, lang),
                                                'candyLink':translatedLinks(lang),
                                                }, *args, **kwargs)


def addLinks(*args):
    result=''
    for i in args:
        if result and result[-1]=='/':result=result[:-1]
        if i and i[-1]=='/':i=i[:-1]
        if i and i[0]=='/':i=i[1:]
        if result and i: result+='/'
        result+=i
    return result


def provideSitemap(request, add_pages=[], remove_pages=[], remove_paths=[]):
    from django.http import HttpResponse
    result='<?xml version="1.0" encoding="UTF-8"?>'+'\n'
    result+='<urlset xmlns="http://www.sitemaps.org/schemas/sitemap/0.9">'+'\n'
    domain= request.build_absolute_uri()
    domain=domain.split('/')[0]+'//'+domain.split('/')[2]+'/'
    paths = []
    for i in get_resolver().url_patterns:
        if str(type(i))=="<class 'django.urls.resolvers.URLPattern'>":
            try:
                route=i.pattern._route
                route=route.split('<')[0]
                if not route == 'sitemap.xml':
                    if 'robots.txt' not in route:
                        paths.append(addLinks(domain,route))
            except: pass
    paths+=add_pages
    paths=list(dict.fromkeys(paths))
    for route in paths:
        removed_path = False
        for removal in remove_paths:
            if route[:len(removal)] == removal: removed_path = True
        if not removed_path and route not in remove_pages:
            result+='<url>'+'\n'
            result+='<loc>'+route+'</loc>'+'\n'
            result+='</url>'+'\n'
    result+='</urlset>'
    result= result.encode('utf-8')
    return HttpResponse(result, content_type='application/xml; charset=utf-8')


def sitemap(add_pages=[], remove_pages=[], remove_paths=[]):
    return [org_path('sitemap.xml', provideSitemap,{'add_pages' :add_pages,'remove_pages': remove_pages, 'remove_paths': remove_paths})]


